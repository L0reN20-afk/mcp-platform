import * as THREE from 'three'
import { gsap } from 'gsap'
import { ParticleSystem } from './types'
import { morphToShape } from './morphingEngine'

// 📜 SCROLL TRIGGERS - Gestione ottimizzata dei trigger

// Dynamic import for ScrollTrigger to avoid SSR issues
let ScrollTrigger: any
if (typeof window !== 'undefined') {
  import('gsap/ScrollTrigger').then(({ ScrollTrigger: ST }) => {
    ScrollTrigger = ST
    gsap.registerPlugin(ScrollTrigger)
  })
}

// 🎬 SETUP SCROLL TRIGGERS UNIFICATI (morphing + progressive separation)
export function setupScrollTriggers(particleSystem: ParticleSystem, scene: THREE.Scene) {
  if (typeof window === 'undefined') return
  
  const initScrollTriggers = () => {
    if (!ScrollTrigger) {
      setTimeout(initScrollTriggers, 100)
      return
    }
    
    console.log('🎬 Inizializzazione ScrollTriggers unificati...')
    
    const sections = ['hero', 'features', 'packages', 'pricing', 'demo']
    
    sections.forEach((section, index) => {
      const nextSection = sections[index + 1]
      
      // 🎯 TRIGGER UNIFICATO per morphing + progressive separation
      ScrollTrigger.create({
        trigger: `#${section}`,
        start: "top center",
        end: "bottom center",
        
        // 🔥 MORPHING TRIGGERS (come originale)
        onEnter: () => {
          console.log(`🔄 Morphing to ${section}`)
          morphToShape(particleSystem, section, scene)
        },
        onEnterBack: () => {
          console.log(`🔄 Morphing back to ${section}`)
          morphToShape(particleSystem, section, scene)
        },
        
        // 🌊 PROGRESSIVE SEPARATION (solo se c'è sezione successiva)
        ...(nextSection && {
          onUpdate: (self) => {
            const progress = self.progress
            
            // 🎯 Progressive Separation: 50% → 80%
            if (progress >= 0.5 && progress <= 0.8) {
              const separationProgress = (progress - 0.5) / 0.3
              applySeparationEffectOptimized(particleSystem, separationProgress)
            }
            // Reset sotto il 50%
            else if (progress < 0.5) {
              resetSeparationEffectOptimized(particleSystem)
            }
          }
        })
      })
    })
  }
  
  initScrollTriggers()
}

// 🌊 SEPARAZIONE OTTIMIZZATA (NO GSAP, transform diretti)
function applySeparationEffectOptimized(particleSystem: ParticleSystem, progress: number) {
  if (!particleSystem.points) return
  
  // 🚀 TRASFORMAZIONE DIRETTA (no gsap.to infinite)
  const targetScale = 1.0 + (progress * 1.0) // Max 2.0x
  
  // Applica direttamente senza animazioni GSAP
  particleSystem.points.scale.set(targetScale, targetScale, targetScale)
  
  // Nessun console.log per non spammare
}

// 🔄 RESET OTTIMIZZATO
function resetSeparationEffectOptimized(particleSystem: ParticleSystem) {
  if (!particleSystem.points) return
  
  // Reset diretto a scala normale
  particleSystem.points.scale.set(1.0, 1.0, 1.0)
}

// 🚫 RIMUOVO setupProgressiveSeparation (ora integrato sopra)
// export function setupProgressiveSeparation() { ... } // RIMOSSO

// 🎮 SETUP PARALLAX EFFECTS (mantenuto invariato)
export function setupParallaxEffects() {
  if (typeof window === 'undefined') return
  
  const initParallax = () => {
    if (!ScrollTrigger) {
      setTimeout(initParallax, 100)
      return
    }
    
    // Parallax per elementi background decorativi
    gsap.utils.toArray('.parallax-element').forEach((element: any) => {
      gsap.to(element, {
        yPercent: -50,
        ease: "none",
        scrollTrigger: {
          trigger: element,
          start: "top bottom",
          end: "bottom top",
          scrub: true // Questo va bene perché è isolato
        }
      })
    })
  }
  
  initParallax()
}

// 🔧 CLEANUP SCROLL TRIGGERS
export function cleanupScrollTriggers() {
  if (ScrollTrigger) {
    ScrollTrigger.getAll().forEach((trigger: any) => trigger.kill())
    console.log('🧹 ScrollTriggers puliti')
  }
}

// 📊 DEBUG SCROLL TRIGGERS
export function debugScrollTriggers() {
  if (ScrollTrigger && process.env.NODE_ENV === 'development') {
    ScrollTrigger.refresh()
    console.log('🔍 ScrollTriggers refreshed per debug')
  }
}
