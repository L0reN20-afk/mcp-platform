'use client'

import { useEffect, useRef } from 'react'
import * as THREE from 'three'

// ðŸ“¦ IMPORT MODULI SPECIALIZZATI
import { ParticleSystem } from './types'
import { ANIMATION_CONFIG } from './constants'
import { generateUniformSpherePositions } from './geometryGenerators'
import { generateBlueColors } from './colorGenerators'
import { 
  createCircleTexture, 
  getOptimalParticleCount, 
  generateOriginalSizes,
  createParticleMaterial,
  setupCamera,
  setupRenderer,
  setupCanvasStyles,
  handleResize,
  cleanupResources
} from './utils'
import { morphToShape } from './morphingEngine'
import { setupScrollTriggers, setupProgressiveSeparation } from './scrollTriggers'

// ðŸŽ¯ COMPONENTE PRINCIPALE SEMPLIFICATO
export default function ParticleBackground() {
  const mountRef = useRef<HTMLDivElement>(null)
  const sceneRef = useRef<THREE.Scene | null>(null)
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null)
  const particleSystemRef = useRef<ParticleSystem | null>(null)
  const animationIdRef = useRef<number>()

  useEffect(() => {
    if (!mountRef.current) return

    console.log('ðŸŽ¯ Inizializzazione sistema particelle modulare con Progressive Separation...')

    // ðŸ—ï¸ SETUP SCENA BASE
    const scene = new THREE.Scene()
    const camera = setupCamera()
    const renderer = setupRenderer()
    
    // ðŸŽ¨ MOUNT RENDERER
    mountRef.current.appendChild(renderer.domElement)
    setupCanvasStyles(renderer.domElement)

    // ðŸŽ¯ INIZIALIZZAZIONE SISTEMA PARTICELLARE
    const particleSystem = initializeParticleSystem(scene)
    
    // ðŸ“¦ SALVA RIFERIMENTI
    sceneRef.current = scene
    rendererRef.current = renderer
    particleSystemRef.current = particleSystem

    // ðŸŽ¬ ANIMATION LOOP
    const animate = () => {
      animationIdRef.current = requestAnimationFrame(animate)
      
      if (particleSystem.points) {
        // Rotazione continua
        particleSystem.points.rotation.y += ANIMATION_CONFIG.rotationSpeed.y
        particleSystem.points.rotation.x += ANIMATION_CONFIG.rotationSpeed.x
        
        // ðŸŒŠ MORPHING CONTINUO per forme dinamiche
        if (particleSystem.currentShape === 'pricing') {
          updateMorphingBlob(particleSystem)
        }
        
        // ðŸ§¬ ANIMAZIONE DNA CONTINUA
        if (particleSystem.currentShape === 'demo') {
          updateDNAHelix(particleSystem)
        }
      }

      renderer.render(scene, camera)
    }
    animate()

    // ðŸ“œ SETUP SCROLL TRIGGERS
    setupScrollTriggers(particleSystem, scene)
    
    // ðŸŒŠ SETUP PROGRESSIVE SEPARATION (NUOVA FEATURE!)
    setupProgressiveSeparation(particleSystem)

    // ðŸ“± RESIZE HANDLER
    const resizeHandler = () => handleResizeEvent(camera, renderer, particleSystem, scene)
    window.addEventListener('resize', resizeHandler)

    console.log('âœ… Sistema particelle modulare inizializzato con Progressive Separation!')

    // ðŸ§¹ CLEANUP
    return () => {
      window.removeEventListener('resize', resizeHandler)
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current)
      }
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement)
      }
      
      // Cleanup completo
      if (particleSystem) {
        cleanupResources(
          renderer,
          particleSystem.geometry,
          particleSystem.material,
          particleSystem.material.map as THREE.CanvasTexture
        )
      }
    }
  }, [])

  return (
    <div 
      ref={mountRef} 
      className="particles-container" 
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        zIndex: -1,
        pointerEvents: 'none'
      }} 
    />
  )
}

// ðŸ—ï¸ INIZIALIZZAZIONE SISTEMA PARTICELLARE
function initializeParticleSystem(scene: THREE.Scene): ParticleSystem {
  // Calcola numero ottimale per la forma iniziale (hero)
  const currentParticleCount = getOptimalParticleCount('hero')

  // ðŸŽ¨ SETUP GEOMETRIA
  const geometry = new THREE.BufferGeometry()
  const positions = new Float32Array(currentParticleCount * 3)
  const colors = new Float32Array(currentParticleCount * 3)
  const sizes = new Float32Array(currentParticleCount)

  // ðŸŒ INIZIALIZZAZIONE PARTICELLE (Sfera uniforme)
  generateUniformSpherePositions(positions, currentParticleCount)
  generateBlueColors(colors, currentParticleCount)
  generateOriginalSizes(sizes, currentParticleCount)

  // ðŸ“ SETUP ATTRIBUTI GEOMETRIA
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1))

  // ðŸŽ¨ SETUP MATERIALE
  const circleTexture = createCircleTexture()
  const material = createParticleMaterial(circleTexture)

  // ðŸŽ¯ CREAZIONE POINTS
  const points = new THREE.Points(geometry, material)
  scene.add(points)

  // ðŸ“¦ CREAZIONE SISTEMA PARTICELLARE
  const particleSystem: ParticleSystem = {
    geometry,
    material,
    points,
    targetPositions: new Float32Array(currentParticleCount * 3),
    colors: new Float32Array(currentParticleCount * 3),
    currentShape: 'hero',
    startTime: Date.now(),
    currentParticleCount
  }

  return particleSystem
}

// ðŸŒŠ UPDATE MORPHING BLOB
function updateMorphingBlob(particleSystem: ParticleSystem) {
  const currentTime = Date.now() - particleSystem.startTime
  const positions = particleSystem.geometry.attributes.position.array as Float32Array
  const count = particleSystem.currentParticleCount
  
  // Import dinamico per evitare circular dependencies
  import('./geometryGenerators').then(({ generateMorphingBlobPositions }) => {
    generateMorphingBlobPositions(positions, count, currentTime)
    particleSystem.geometry.attributes.position.needsUpdate = true
  })
}

// ðŸ§¬ UPDATE DNA HELIX
function updateDNAHelix(particleSystem: ParticleSystem) {
  const currentTime = Date.now() - particleSystem.startTime
  const positions = particleSystem.geometry.attributes.position.array as Float32Array
  const count = particleSystem.currentParticleCount
  
  // Import dinamico per evitare circular dependencies
  import('./geometryGenerators').then(({ generateDoubleHelixPositions }) => {
    generateDoubleHelixPositions(positions, count, currentTime)
    particleSystem.geometry.attributes.position.needsUpdate = true
  })
}

// ðŸ“± GESTIONE RESIZE CON AGGIORNAMENTO CONTEGGIO
function handleResizeEvent(
  camera: THREE.PerspectiveCamera,
  renderer: THREE.WebGLRenderer,
  particleSystem: ParticleSystem,
  scene: THREE.Scene
) {
  if (!camera || !renderer || !particleSystem) return
  
  // Resize base
  handleResize(camera, renderer, particleSystem.material)
  
  // ðŸŽ¯ RICALCOLA NUMERO OTTIMALE PER LA FORMA CORRENTE
  const newOptimalCount = getOptimalParticleCount(particleSystem.currentShape)
  
  // Se il numero ottimale Ã¨ cambiato, ricrea la forma
  if (newOptimalCount !== particleSystem.currentParticleCount) {
    console.log(`ðŸ“± Resize: Aggiornamento particelle ${particleSystem.currentParticleCount} â†’ ${newOptimalCount}`)
    morphToShape(particleSystem, particleSystem.currentShape, scene, true) // skipAnimation = true
  }
  
  console.log(`ðŸ“± Resize: particelle: ${particleSystem.currentParticleCount}`)
}
