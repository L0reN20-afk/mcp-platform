import * as THREE from 'three'
import { OPTIMAL_PARTICLE_COUNTS, MATERIAL_CONFIG, QUALITY_THRESHOLDS } from './constants'

// üõ†Ô∏è UTILITY E HELPERS DEL SISTEMA PARTICELLARE

// üé® TEXTURE CIRCOLARE per fare cerchi invece di quadratini
export function createCircleTexture(): THREE.CanvasTexture {
  const canvas = document.createElement('canvas')
  canvas.width = 64
  canvas.height = 64
  const context = canvas.getContext('2d')!
  
  const centerX = canvas.width / 2
  const centerY = canvas.height / 2
  const radius = 28
  
  // Crea gradiente radiale per anti-aliasing
  const gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius)
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)')
  gradient.addColorStop(0.7, 'rgba(255, 255, 255, 1)')
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)')
  
  context.fillStyle = gradient
  context.fillRect(0, 0, canvas.width, canvas.height)
  
  return new THREE.CanvasTexture(canvas)
}

// üéØ CALCOLO NUMERO OTTIMALE DI PARTICELLE (SSR Safe)
export function getOptimalParticleCount(shape: string): number {
  // üîí SSR Safety Check
  if (typeof window === 'undefined') {
    return OPTIMAL_PARTICLE_COUNTS.hero // Fallback sicuro per server
  }
  
  const baseMultiplier = Math.min(window.devicePixelRatio || 1, 2)
  
  switch(shape) {
    case 'hero': // Sfera - numeri che danno buona distribuzione Fibonacci
      return Math.floor(OPTIMAL_PARTICLE_COUNTS.hero * baseMultiplier)
    
    case 'features': // Toro - numero che si divide bene in griglia 2D
      const torusGrid = Math.floor(45 * baseMultiplier) // 45x45 = 2025
      return torusGrid * torusGrid
    
    case 'packages': // Cubo - divisibile per 6 facce, griglia quadrata per faccia
      const faceGrid = Math.floor(18 * baseMultiplier) // 18x18 per faccia
      return faceGrid * faceGrid * 6 // 6 facce = 1944 particelle
    
    case 'pricing': // Blob morfante - numero flessibile ma abbondante per dettagli
      return Math.floor(OPTIMAL_PARTICLE_COUNTS.pricing * baseMultiplier)
    
    case 'demo': // DNA Doppia Elica - numero ottimale per due spirali
      return Math.floor(OPTIMAL_PARTICLE_COUNTS.demo * baseMultiplier)
    
    default:
      return Math.floor(OPTIMAL_PARTICLE_COUNTS.hero * baseMultiplier)
  }
}

// üìê GENERATORE DI DIMENSIONI ORIGINALI
export function generateOriginalSizes(sizes: Float32Array, count: number) {
  for (let i = 0; i < count; i++) {
    sizes[i] = 0.5 + Math.random() * 1.5 // Dimensioni casuali
  }
}

// üîß CREAZIONE MATERIALE PARTICELLE (SSR Safe)
export function createParticleMaterial(circleTexture: THREE.CanvasTexture): THREE.PointsMaterial {
  // üîí SSR Safety Check
  const pixelRatio = typeof window !== 'undefined' 
    ? Math.min(window.devicePixelRatio || 1, 2)
    : 1 // Fallback per server
  
  const adjustedSize = MATERIAL_CONFIG.baseSize * pixelRatio
  
  return new THREE.PointsMaterial({
    size: adjustedSize,
    sizeAttenuation: MATERIAL_CONFIG.sizeAttenuation,
    vertexColors: true,
    transparent: MATERIAL_CONFIG.transparent,
    opacity: MATERIAL_CONFIG.opacity,
    blending: THREE.AdditiveBlending,
    map: circleTexture
  })
}

// üì± DETECTION PERFORMANCE DISPOSITIVO (SSR Safe)
export function detectDevicePerformance(): {
  isHighPerformance: boolean
  pixelRatio: number
  memoryGb: number | null
  cores: number
} {
  // üîí SSR Safety Check
  if (typeof window === 'undefined' || typeof document === 'undefined') {
    return {
      isHighPerformance: true, // Assume high performance on server
      pixelRatio: 1,
      memoryGb: null,
      cores: 1
    }
  }

  const canvas = document.createElement('canvas')
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl')
  
  if (!gl) {
    return {
      isHighPerformance: false,
      pixelRatio: 1,
      memoryGb: null,
      cores: 1
    }
  }

  // Check device specs
  const memory = (navigator as any).deviceMemory || null
  const cores = navigator.hardwareConcurrency || 1
  const pixelRatio = window.devicePixelRatio || 1
  
  // Performance thresholds
  const { lowEnd } = QUALITY_THRESHOLDS
  const isLowEnd = (memory && memory < lowEnd.memory) || 
                   cores < lowEnd.cores || 
                   pixelRatio > lowEnd.pixelRatio
  
  return {
    isHighPerformance: !isLowEnd,
    pixelRatio,
    memoryGb: memory,
    cores
  }
}

// üéÆ SETUP CAMERA (SSR Safe)
export function setupCamera(): THREE.PerspectiveCamera {
  // üîí SSR Safety Check - Default dimensions se window non disponibile
  const width = typeof window !== 'undefined' ? window.innerWidth : 1920
  const height = typeof window !== 'undefined' ? window.innerHeight : 1080
  
  const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000)
  camera.position.z = 45 // Posizione ottimale per vedere le forme
  return camera
}

// üñ•Ô∏è SETUP RENDERER (SSR Safe)
export function setupRenderer(): THREE.WebGLRenderer {
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false })
  
  // üîí SSR Safety Check
  if (typeof window !== 'undefined') {
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
  } else {
    renderer.setSize(1920, 1080) // Fallback dimensions
    renderer.setPixelRatio(1)
  }
  
  renderer.setClearColor(0x000000, 0) // Background trasparente
  
  return renderer
}

// üé® SETUP CANVAS STYLES
export function setupCanvasStyles(canvas: HTMLCanvasElement) {
  canvas.style.position = 'fixed'
  canvas.style.top = '0'
  canvas.style.left = '0'
  canvas.style.zIndex = '-1'
  canvas.style.pointerEvents = 'none'
}

// üìä RESIZE HANDLER (SSR Safe)
export function handleResize(
  camera: THREE.PerspectiveCamera, 
  renderer: THREE.WebGLRenderer, 
  material: THREE.PointsMaterial
) {
  // üîí SSR Safety Check
  if (typeof window === 'undefined') return
  
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
  
  // Mantieni dimensioni particelle fisse per devicePixelRatio
  const pixelRatio = Math.min(window.devicePixelRatio || 1, 2)
  const adjustedSize = MATERIAL_CONFIG.baseSize * pixelRatio
  material.size = adjustedSize
}

// üßπ CLEANUP RESOURCES
export function cleanupResources(
  renderer: THREE.WebGLRenderer,
  geometry: THREE.BufferGeometry,
  material: THREE.PointsMaterial,
  texture: THREE.CanvasTexture
) {
  renderer.dispose()
  geometry.dispose()
  material.dispose()
  texture.dispose()
}

// üì± MOBILE DEVICE DETECTION - Rilevamento intelligente dispositivi mobili (SSR Safe)
export function isMobileDevice(): boolean {
  // üîí SSR Safety Check - Se siamo lato server, ritorna false
  if (typeof window === 'undefined' || typeof navigator === 'undefined') {
    return false
  }
  
  // Check viewport width (primary indicator)
  const isMobileViewport = window.innerWidth <= 768
  
  // Check user agent (secondary confirmation)
  const userAgent = navigator.userAgent || navigator.vendor || (window as any).opera
  const isMobileUA = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(userAgent)
  
  // Check touch capability
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0
  
  // Combined detection
  return isMobileViewport || (isMobileUA && isTouchDevice)
}

// üéØ CALCOLO PARTICELLE CON OTTIMIZZAZIONI MOBILE (SSR Safe)
export function getOptimalParticleCountWithMobile(shape: string): number {
  const isMobile = isMobileDevice()
  
  if (isMobile) {
    // üì± MOBILE: Usa MOBILE_CONFIG per performance ottimali
    const { MOBILE_CONFIG } = require('./constants')
    const baseCount = Math.min(MOBILE_CONFIG.maxParticles, 800)
    
    // Riduci ulteriormente in base alla forma
    switch(shape) {
      case 'hero': return Math.floor(baseCount * 0.8)      // 640 particelle
      case 'features': return Math.floor(baseCount * 0.7)  // 560 particelle
      case 'packages': return Math.floor(baseCount * 0.6)  // 480 particelle
      case 'pricing': return Math.floor(baseCount * 0.9)   // 720 particelle (morfing needs more)
      case 'demo': return Math.floor(baseCount * 0.7)      // 560 particelle
      default: return Math.floor(baseCount * 0.8)
    }
  }
  
  // üñ•Ô∏è DESKTOP: Usa la funzione esistente (ZERO modifiche)
  return getOptimalParticleCount(shape)
}

// üñ•Ô∏è SETUP RENDERER CON FALLBACK MOBILE (SSR Safe)
export function setupRendererWithMobileFallback(): THREE.WebGLRenderer {
  const isMobile = isMobileDevice()
  
  // üñ•Ô∏è DESKTOP: Renderer identico a prima
  if (!isMobile) {
    return setupRenderer()
  }
  
  // üì± MOBILE: Ottimizzazioni specifiche
  const renderer = new THREE.WebGLRenderer({ 
    antialias: false,  // Disabilita antialiasing per performance
    alpha: true,       // Abilita trasparenza per overlay
    powerPreference: 'low-power'  // Ottimizzazione batteria
  })
  
  // üîí SSR Safety Check
  if (typeof window !== 'undefined') {
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.setPixelRatio(1) // Forza pixel ratio 1 su mobile
  } else {
    renderer.setSize(1920, 1080) // Fallback dimensions
    renderer.setPixelRatio(1)
  }
  
  renderer.setClearColor(0x000000, 0.3) // Background semi-trasparente per contrasto
  
  return renderer
}

// üé® MATERIALE PARTICELLE CON OTTIMIZZAZIONI MOBILE (SSR Safe)
export function createParticleMaterialWithMobileOptimizations(circleTexture: THREE.CanvasTexture): THREE.PointsMaterial {
  const isMobile = isMobileDevice()
  
  // üñ•Ô∏è DESKTOP: Materiale identico a prima
  if (!isMobile) {
    return createParticleMaterial(circleTexture)
  }
  
  // üì± MOBILE: Ottimizzazioni specifiche
  return new THREE.PointsMaterial({
    size: MATERIAL_CONFIG.baseSize * 1.2, // Particelle leggermente pi√π grandi per visibilit√†
    sizeAttenuation: MATERIAL_CONFIG.sizeAttenuation,
    vertexColors: true,
    transparent: MATERIAL_CONFIG.transparent,
    opacity: 0.95, // Opacit√† pi√π alta per contrasto
    blending: THREE.AdditiveBlending,
    map: circleTexture
  })
}

// üìä RESIZE HANDLER CON SUPPORTO MOBILE (SSR Safe)
export function handleResizeWithMobile(
  camera: THREE.PerspectiveCamera, 
  renderer: THREE.WebGLRenderer, 
  material: THREE.PointsMaterial
) {
  // üîí SSR Safety Check
  if (typeof window === 'undefined') return
  
  const isMobile = isMobileDevice()
  
  // üñ•Ô∏è DESKTOP: Resize identico a prima
  if (!isMobile) {
    return handleResize(camera, renderer, material)
  }
  
  // üì± MOBILE: Resize ottimizzato
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
  
  // Mantieni pixel ratio fisso a 1 su mobile
  renderer.setPixelRatio(1)
  material.size = MATERIAL_CONFIG.baseSize * 1.2
}