import * as THREE from 'three'
import { gsap } from 'gsap'
import { ParticleSystem } from './types'
import { morphToShape } from './morphingEngine'

// üìú SCROLL TRIGGERS - Gestione ottimizzata dei trigger (con debug)

// Dynamic import for ScrollTrigger to avoid SSR issues
let ScrollTrigger: any
if (typeof window !== 'undefined') {
  import('gsap/ScrollTrigger').then(({ ScrollTrigger: ST }) => {
    ScrollTrigger = ST
    gsap.registerPlugin(ScrollTrigger)
  })
}

// üé¨ SETUP SCROLL TRIGGERS UNIFICATI (morphing + progressive separation)
export function setupScrollTriggers(particleSystem: ParticleSystem, scene: THREE.Scene) {
  if (typeof window === 'undefined') return
  
  const initScrollTriggers = () => {
    if (!ScrollTrigger) {
      setTimeout(initScrollTriggers, 100)
      return
    }
    
    // üßπ PULIZIA PREVENTIVA - Elimina eventuali trigger esistenti
    ScrollTrigger.getAll().forEach((trigger: any) => trigger.kill())
    
    console.log('üé¨ Inizializzazione ScrollTriggers unificati con debug...')
    
    const sections = ['hero', 'features', 'packages', 'pricing', 'demo']
    
    sections.forEach((section, index) => {
      const nextSection = sections[index + 1]
      
      console.log(`üîß Creando trigger per sezione: ${section}`)
      
      // üéØ TRIGGER UNIFICATO per morphing + progressive separation
      const trigger = ScrollTrigger.create({
        trigger: `#${section}`,
        start: "top center",
        end: "bottom center",
        
        // üìä DEBUG CALLBACKS
        onEnter: () => {
          console.log(`üü¢ ENTER: Entering ${section} (morphing gestito da onUpdate)`)
        },
        onEnterBack: () => {
          console.log(`üü£ ENTER BACK: Entering back ${section} (morphing gestito da onUpdate)`)
        },
        onLeave: () => {
          console.log(`üî¥ LEAVE: Leaving ${section}`)
        },
        onLeaveBack: () => {
          console.log(`üü° LEAVE BACK: Leaving back ${section}`)
        },
        
        // üåä PROGRESSIVE SEPARATION + MORPHING UNIFICATI
        ...(nextSection && {
          onUpdate: (self) => {
            const progress = self.progress
            
            // Debug progress solo ogni 10%
            if (progress % 0.1 < 0.01) {
              console.log(`üìä ${section}: ${(progress * 100).toFixed(0)}%`)
            }
            
            // üéØ Progressive Separation: 50% ‚Üí 80%
            if (progress >= 0.5 && progress < 0.8) {
              const separationProgress = (progress - 0.5) / 0.3
              applySeparationEffectOptimized(particleSystem, separationProgress)
            }
            // üöÄ MORPHING FINALE: 80% ‚Üí 100%
            else if (progress >= 0.8) {
              // Triggera morphing solo una volta quando raggiungi 80%
              if (!particleSystem.isMorphing) {
                console.log(`üöÄ TRIGGER MORPHING a 80%: ${section} ‚Üí ${nextSection}`)
                particleSystem.isMorphing = true
                morphToShape(particleSystem, nextSection, scene)
              }
            }
            // Reset sotto il 50%
            else if (progress < 0.5) {
              resetSeparationEffectOptimized(particleSystem)
              particleSystem.isMorphing = false // Reset flag
            }
          }
        }),
        
        // üéØ GESTIONE SEZIONI SENZA NEXT (ultima sezione)
        ...(!nextSection && {
          onUpdate: (self) => {
            const progress = self.progress
            
            // Solo progressive separation per l'ultima sezione, nessun morphing
            if (progress >= 0.5 && progress <= 0.8) {
              const separationProgress = (progress - 0.5) / 0.3
              applySeparationEffectOptimized(particleSystem, separationProgress)
            } else if (progress < 0.5) {
              resetSeparationEffectOptimized(particleSystem)
            }
          }
        })
      })
      
      console.log(`‚úÖ Trigger creato per ${section}:`, trigger)
    })
    
    // üîç DEBUG INFO
    const allTriggers = ScrollTrigger.getAll()
    console.log(`üéØ Totale ScrollTriggers attivi: ${allTriggers.length}`)
    console.log('üìã Lista triggers:', allTriggers.map((t: any) => t.vars.trigger))
    
    // üîÑ REFRESH PREVENTIVO
    ScrollTrigger.refresh()
    console.log('üîÑ ScrollTrigger.refresh() completato')
  }
  
  initScrollTriggers()
}

// üåä SEPARAZIONE OTTIMIZZATA (NO GSAP, transform diretti)
function applySeparationEffectOptimized(particleSystem: ParticleSystem, progress: number) {
  if (!particleSystem.points) return
  
  // üöÄ TRASFORMAZIONE DIRETTA (no gsap.to infinite)
  const targetScale = 1.0 + (progress * 1.0) // Max 2.0x
  
  // Applica direttamente senza animazioni GSAP
  particleSystem.points.scale.set(targetScale, targetScale, targetScale)
  
  // Debug solo a 25%, 50%, 75%
  if (progress === 0.25 || progress === 0.5 || progress === 0.75) {
    console.log(`üåä Separazione: ${(progress * 100).toFixed(0)}% - Scala: ${targetScale.toFixed(2)}x`)
  }
}

// üîÑ RESET OTTIMIZZATO
function resetSeparationEffectOptimized(particleSystem: ParticleSystem) {
  if (!particleSystem.points) return
  
  // Reset diretto a scala normale
  particleSystem.points.scale.set(1.0, 1.0, 1.0)
  console.log('üîÑ Reset separazione a scala 1.0x')
}

// üéÆ SETUP PARALLAX EFFECTS (mantenuto ma con debug)
export function setupParallaxEffects() {
  if (typeof window === 'undefined') return
  
  const initParallax = () => {
    if (!ScrollTrigger) {
      setTimeout(initParallax, 100)
      return
    }
    
    console.log('üéÆ Inizializzazione Parallax Effects...')
    
    // Parallax per elementi background decorativi
    const parallaxElements = gsap.utils.toArray('.parallax-element')
    console.log(`üéÆ Trovati ${parallaxElements.length} elementi parallax`)
    
    parallaxElements.forEach((element: any, index: number) => {
      gsap.to(element, {
        yPercent: -50,
        ease: "none",
        scrollTrigger: {
          trigger: element,
          start: "top bottom",
          end: "bottom top",
          scrub: true,
          onUpdate: (self) => {
            if (index === 0) { // Log solo per il primo elemento
              console.log(`üéÆ Parallax progress: ${(self.progress * 100).toFixed(0)}%`)
            }
          }
        }
      })
    })
  }
  
  initParallax()
}

// üîß CLEANUP SCROLL TRIGGERS (con debug)
export function cleanupScrollTriggers() {
  if (ScrollTrigger) {
    const beforeCount = ScrollTrigger.getAll().length
    ScrollTrigger.getAll().forEach((trigger: any) => trigger.kill())
    const afterCount = ScrollTrigger.getAll().length
    console.log(`üßπ ScrollTriggers puliti: ${beforeCount} ‚Üí ${afterCount}`)
  }
}

// üìä DEBUG SCROLL TRIGGERS (migliorato)
export function debugScrollTriggers() {
  if (ScrollTrigger) {
    console.log('üîç === SCROLL TRIGGER DEBUG ===')
    const triggers = ScrollTrigger.getAll()
    console.log(`üìä Totale triggers: ${triggers.length}`)
    
    triggers.forEach((trigger: any, index: number) => {
      console.log(`${index + 1}. Trigger:`, {
        element: trigger.vars.trigger,
        start: trigger.vars.start,
        end: trigger.vars.end,
        scrub: trigger.vars.scrub,
        pin: trigger.vars.pin,
        isActive: trigger.isActive
      })
    })
    
    ScrollTrigger.refresh()
    console.log('üîÑ ScrollTrigger refreshed')
    console.log('üîç === END DEBUG ===')
  }
}

// üéØ AUTO-DEBUG ogni 5 secondi in development
if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
  setInterval(() => {
    if (ScrollTrigger) {
      const triggers = ScrollTrigger.getAll()
      if (triggers.length > 0) {
        console.log(`üîç [AUTO-DEBUG] ${triggers.length} ScrollTriggers attivi`)
      }
    }
  }, 5000)
}
